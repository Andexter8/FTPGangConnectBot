"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XboxRTA = void 0;
const axios_1 = __importDefault(require("axios"));
const debug_1 = __importDefault(require("debug"));
const ws_1 = require("ws");
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const constants_1 = require("./common/constants");
const debug = (0, debug_1.default)('xbox-rta');
const address = 'wss://rta.xboxlive.com/connect';
const promiseMap = new Map();
class XboxRTA extends tiny_typed_emitter_1.TypedEmitter {
    constructor(authflow) {
        super();
        this.subscriptions = new Map();
        this.ws = null;
        this.authorization = null;
        this.heartbeatTimeout = null;
        this.reconnectTimeout = null;
        this.sequenceId = 0;
        this.authflow = authflow;
        this.queue = [];
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) === ws_1.WebSocket.OPEN)
                throw new Error(`Already connected to ${address}`);
            yield this.init();
        });
    }
    destroy() {
        return __awaiter(this, arguments, void 0, function* (resume = false) {
            debug('Disconnecting from RTA');
            if (this.heartbeatTimeout) {
                clearTimeout(this.heartbeatTimeout);
                this.heartbeatTimeout = null;
            }
            if (this.reconnectTimeout) {
                clearTimeout(this.reconnectTimeout);
                this.reconnectTimeout = null;
            }
            if (this.ws) {
                this.ws.removeListener('pong', () => { this.heartbeat(); });
                this.ws.onmessage = null;
                this.ws.onclose = null;
                const shouldClose = this.ws.readyState === ws_1.WebSocket.OPEN;
                if (shouldClose) {
                    let outerResolve;
                    const promise = new Promise((resolve) => {
                        outerResolve = resolve;
                    });
                    this.ws.onclose = outerResolve;
                    this.ws.close(1000, 'Normal Closure');
                    yield promise;
                }
                this.ws.onerror = null;
            }
            if (resume) {
                return this.init();
            }
        });
    }
    subscribe(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            debug('Subscribing', uri);
            const sequenceId = this.sequenceId++;
            return this.send(constants_1.MessageType.Subscribe, sequenceId, uri);
        });
    }
    unsubscribe(subscriptionId) {
        return __awaiter(this, void 0, void 0, function* () {
            debug('Unsubscribing', subscriptionId);
            const sequenceId = this.sequenceId++;
            return this.send(constants_1.MessageType.Unsubscribe, sequenceId, subscriptionId);
        });
    }
    send(type, sequenceId, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            let data = '';
            switch (type) {
                case constants_1.MessageType.Subscribe:
                    data = `[${type},${sequenceId},"${payload}"]`;
                    break;
                case constants_1.MessageType.Unsubscribe:
                    data = `[${type},${sequenceId},${payload}]`;
                    break;
                default:
                    data = `[${type},${sequenceId},${payload}]`;
                    break;
            }
            debug('Sending', data);
            if (((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) === ws_1.WebSocket.OPEN) {
                this.ws.send(data);
            }
            else {
                this.queue.push(data);
            }
            const response = yield new Promise((resolve, reject) => {
                const sendTimeout = setTimeout(() => reject(new Error('Timeout')), 30000);
                const onRes = (res) => {
                    clearTimeout(sendTimeout);
                    resolve(res);
                };
                const onRej = (err) => {
                    clearTimeout(sendTimeout);
                    reject(err);
                };
                promiseMap.set(sequenceId, { resolve: onRes, reject: onRej, data: payload });
            });
            return response;
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const xbl = yield this.authflow.getXboxToken('http://xboxlive.com', true);
            this.authorization = `XBL3.0 x=${xbl.userHash};${xbl.XSTSToken}`;
            debug('Fetched XBL Token', xbl);
            const nonce = yield (0, axios_1.default)('https://rta.xboxlive.com/nonce', { headers: { authorization: this.authorization } })
                .then(res => res.data.nonce);
            debug('Fetched RTA nonce', nonce);
            const address = `wss://rta.xboxlive.com/connect?nonce=${nonce}`;
            debug(`Connecting to ${address}`);
            const ws = new ws_1.WebSocket(address, 'rta.xboxlive.com.V2');
            ws.on('pong', () => { this.heartbeat(); });
            ws.onopen = () => {
                this.onOpen();
            };
            ws.onclose = (event) => {
                this.onClose(event.code, event.reason);
            };
            ws.onerror = (event) => {
                this.onError(event.error);
            };
            ws.onmessage = (event) => {
                this.onMessage(event.data);
            };
            this.ws = ws;
        });
    }
    onOpen() {
        debug('RTA Connected to', address);
        this.reconnectTimeout = setTimeout(() => {
            debug(`Reconnecting to ${address}`);
            this.destroy(true);
        }, 90 * 60 * 1000);
        this.queue.forEach(message => this.ws.send(message));
        this.queue = [];
        this.subscriptions.forEach((sub) => {
            if (sub.uri) {
                void this.send(sub.type, sub.sequenceId, sub.uri)
                    .catch((err) => { debug('Resubscribe failed', err); });
            }
        });
    }
    onError(err) {
        debug('RTA Error', err);
    }
    onClose(code, reason) {
        debug(`RTA Disconnected from ${address} with code ${code} and reason ${reason}`);
        if (code === 1006) {
            debug('RTA Connection Closed Unexpectedly');
            if (this.reconnectTimeout) {
                clearTimeout(this.reconnectTimeout);
            }
            this.destroy(true);
        }
    }
    onMessage(res) {
        var _a;
        if (!(typeof res === 'string'))
            return debug('Recieved non-string message', res);
        const msgJson = JSON.parse(res);
        const messageType = msgJson[0];
        debug('Recieved message', res);
        switch (messageType) {
            case constants_1.MessageType.Subscribe: {
                const [type, sequenceId, status, subscriptionId, data] = msgJson;
                const promise = promiseMap.get(sequenceId);
                if (status !== constants_1.StatusCode.Success) {
                    debug('Subscribe failed', status);
                    promise === null || promise === void 0 ? void 0 : promise.reject(new Error(`Subscribe failed with status code ${status} ${(0, constants_1.convertRTAStatus)(status)}`));
                    this.emit('error', new Error(`Subscribe failed with status code ${status} ${(0, constants_1.convertRTAStatus)(status)}`));
                }
                else {
                    const sub = { type, sequenceId, status, subscriptionId, data, uri: (_a = promise === null || promise === void 0 ? void 0 : promise.data) !== null && _a !== void 0 ? _a : null };
                    promise === null || promise === void 0 ? void 0 : promise.resolve(sub);
                    this.emit('subscribe', sub);
                    this.subscriptions.set(sequenceId, sub);
                }
                break;
            }
            case constants_1.MessageType.Unsubscribe: {
                const [type, sequenceId, status] = msgJson;
                const promise = promiseMap.get(sequenceId);
                if (status !== constants_1.StatusCode.Success) {
                    debug('Unsubscribe failed', status);
                    promise === null || promise === void 0 ? void 0 : promise.reject(new Error(`Unsubscribe failed with status code ${status} ${(0, constants_1.convertRTAStatus)(status)}`));
                    this.emit('error', new Error(`Unsubscribe failed with status code ${status} ${(0, constants_1.convertRTAStatus)(status)}`));
                }
                else {
                    promise === null || promise === void 0 ? void 0 : promise.resolve({ type, sequenceId, status });
                    this.emit('unsubscribe', { type, sequenceId, status });
                    this.subscriptions.delete(sequenceId);
                }
                break;
            }
            case constants_1.MessageType.Event: {
                const [type, subscriptionId, data] = msgJson;
                this.emit('event', { type, subscriptionId, data });
                break;
            }
            case constants_1.MessageType.Resync: {
                debug('Recieved resync message', res);
                break;
            }
            default:
                debug('Recieved unknown message', res);
                break;
        }
    }
    heartbeat() {
        debug('RTA Pinged');
        if (this.heartbeatTimeout) {
            clearTimeout(this.heartbeatTimeout);
        }
        this.heartbeatTimeout = setTimeout(() => {
            debug('RTA Ping Timeout');
            this.destroy(true);
        }, 30000);
    }
}
exports.XboxRTA = XboxRTA;
