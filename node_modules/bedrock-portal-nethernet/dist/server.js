"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const debug_1 = __importDefault(require("debug"));
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const serverPlayer_1 = require("./serverPlayer");
const util_1 = require("./datatypes/util");
const options_1 = require("./options");
const serializer_1 = require("./transforms/serializer");
const signal_1 = require("./signaling/signal");
const server_1 = require("./nethernet/server");
const framer_1 = require("./transforms/framer");
const debug = (0, debug_1.default)('bedrock-portal-nethernet');
class Server extends tiny_typed_emitter_1.TypedEmitter {
    options;
    serializer;
    deserializer;
    clients;
    clientCount;
    conLog;
    batchHeader;
    disableEncryption;
    compressionAlgorithm;
    compressionLevel;
    compressionThreshold;
    compressionHeader;
    signaling;
    nethernet;
    constructor(options = {}) {
        super();
        this.options = { ...options_1.defaultOptions, ...options };
        this.serializer = (0, serializer_1.createSerializer)(this.options.version);
        this.deserializer = (0, serializer_1.createDeserializer)(this.options.version);
        this.clients = new Map();
        this.clientCount = 0;
        this.conLog = debug;
        this.batchHeader = [];
        this.disableEncryption = true;
        this.setCompressor(this.options.compressionAlgorithm, this.options.compressionLevel, this.options.compressionThreshold);
    }
    setCompressor(algorithm, level = 1, threshold = 256) {
        switch (algorithm) {
            case framer_1.CompressionAlgorithm.None:
                this.compressionAlgorithm = framer_1.CompressionAlgorithm.None;
                this.compressionLevel = 0;
                this.compressionHeader = 255;
                break;
            case framer_1.CompressionAlgorithm.Deflate:
                this.compressionAlgorithm = framer_1.CompressionAlgorithm.Deflate;
                this.compressionLevel = level;
                this.compressionThreshold = threshold;
                this.compressionHeader = 0;
                break;
            case framer_1.CompressionAlgorithm.Snappy:
                this.compressionAlgorithm = framer_1.CompressionAlgorithm.Snappy;
                this.compressionLevel = level;
                this.compressionThreshold = threshold;
                this.compressionHeader = 1;
                break;
            default:
                throw new Error(`Unknown compression algorithm: ${algorithm}`);
        }
    }
    onOpenConnection = (conn) => {
        this.conLog('New connection: ', conn?.connectionId);
        const player = new serverPlayer_1.Player(this, conn);
        this.clients.set(conn.connectionId, player);
        this.clientCount++;
        this.emit('connect', player);
    };
    onCloseConnection = (id, reason) => {
        this.conLog('Connection closed:', id, reason);
        const player = this.clients.get(id);
        if (!player) {
            return;
        }
        player.close(reason);
        this.clients.delete(id);
        this.clientCount--;
    };
    onEncapsulated = (buffer, address) => {
        const client = this.clients.get(address);
        if (!client) {
            // Ignore packets from clients that are not connected.
            debug(`Ignoring packet from unknown inet address: ${address}`);
            return;
        }
        process.nextTick(() => client.onDecryptedPacket(buffer));
    };
    async listen(auth, networkId) {
        this.signaling = new signal_1.Signal(auth, networkId, this.options.version);
        this.nethernet = new server_1.Server(this.signaling, networkId);
        await this.nethernet.listen();
        this.nethernet.onOpenConnection = this.onOpenConnection;
        this.nethernet.onCloseConnection = this.onCloseConnection;
        this.nethernet.onEncapsulated = this.onEncapsulated;
    }
    async close(disconnectReason = 'Server closed') {
        for (const player of this.clients.values()) {
            player.disconnect(disconnectReason);
        }
        this.clients.clear();
        this.clientCount = 0;
        await (0, util_1.sleep)(60);
        this.nethernet?.close();
        if (this.signaling) {
            await this.signaling.destroy();
        }
    }
}
exports.Server = Server;
