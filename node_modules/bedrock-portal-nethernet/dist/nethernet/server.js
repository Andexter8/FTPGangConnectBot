"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const werift_1 = require("werift");
const connection_1 = require("./connection");
const signal_1 = require("../signaling/signal");
const struct_1 = require("../signaling/struct");
const debugFn = require('debug')('bedrock-portal-nethernet');
class Server {
    networkId;
    connectionId;
    signaling;
    connections;
    onOpenConnection;
    onCloseConnection;
    onEncapsulated;
    constructor(signaling, networkId = (0, signal_1.getRandomUint64)(), connectionId = (0, signal_1.getRandomUint64)()) {
        this.signaling = signaling;
        this.networkId = networkId;
        this.connectionId = connectionId;
        this.connections = new Map();
        this.onOpenConnection = () => { };
        this.onCloseConnection = () => { };
        this.onEncapsulated = () => { };
    }
    async handleCandidate(signal) {
        const conn = this.connections.get(signal.connectionId);
        if (conn) {
            await conn.rtcConnection.addIceCandidate(new werift_1.RTCIceCandidate({ candidate: signal.data }));
        }
        else {
            debugFn('Received candidate for unknown connection', signal);
        }
    }
    async handleOffer(signal) {
        const rtcConnection = new werift_1.RTCPeerConnection({
            iceServers: this.signaling.credentials,
        });
        const connection = new connection_1.Connection(this, signal.connectionId, rtcConnection);
        this.connections.set(signal.connectionId, connection);
        rtcConnection.onicecandidate = (e) => {
            if (e.candidate) {
                this.signaling.write(new struct_1.SignalStructure(struct_1.SignalType.CandidateAdd, signal.connectionId, e.candidate.candidate, signal.networkId));
            }
        };
        rtcConnection.ondatachannel = ({ channel }) => {
            if (channel.label === 'ReliableDataChannel')
                connection.setChannels(channel);
            if (channel.label === 'UnreliableDataChannel')
                connection.setChannels(null, channel);
        };
        rtcConnection.onconnectionstatechange = () => {
            const state = rtcConnection.connectionState;
            if (state === 'connected')
                this.onOpenConnection(connection);
            if (state === 'disconnected')
                this.onCloseConnection(signal.connectionId, 'disconnected');
        };
        await rtcConnection.setRemoteDescription({ type: 'offer', sdp: signal.data });
        const answer = await rtcConnection.createAnswer();
        await rtcConnection.setLocalDescription(answer);
        this.signaling.write(new struct_1.SignalStructure(struct_1.SignalType.ConnectResponse, signal.connectionId, answer.sdp, signal.networkId));
    }
    async listen() {
        await this.signaling.connect();
        this.signaling.on('signal', (signal) => {
            switch (signal.type) {
                case struct_1.SignalType.ConnectRequest:
                    this.handleOffer(signal);
                    break;
                case struct_1.SignalType.CandidateAdd:
                    this.handleCandidate(signal);
                    break;
                default:
                    debugFn('Received signal for unknown type', signal);
            }
        });
    }
    close() {
        for (const conn of this.connections.values()) {
            conn.close();
        }
    }
}
exports.Server = Server;
