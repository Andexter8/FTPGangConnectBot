"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Player = exports.ClientStatus = void 0;
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const loginVerify_1 = __importDefault(require("./handshake/loginVerify"));
const keyExchange_1 = require("./handshake/keyExchange");
const util_1 = require("./datatypes/util");
const options_1 = require("./options");
const framer_1 = require("./transforms/framer");
const debug = require('debug')('bedrock-portal-nethernet');
exports.ClientStatus = {
    Disconnected: 0,
    Connecting: 1,
    Authenticating: 2, // Handshaking
    Initializing: 3, // Authed, need to spawn
    Initialized: 4, // play_status spawn sent by server, client responded with SetPlayerInit packet
};
class Player extends tiny_typed_emitter_1.TypedEmitter {
    server;
    // defined in KeyExchange
    ecdhKeyPair;
    publicKeyDER;
    privateKeyPEM;
    clientX509;
    sharedSecret;
    secretKeyBytes;
    // defined in LoginVerify
    decodeLoginJWT;
    encodeLoginJWT;
    inLog;
    outLog;
    _sentNetworkSettings;
    serializer;
    deserializer;
    batchHeader;
    disableEncryption;
    compressionAlgorithm;
    compressionLevel;
    compressionThreshold;
    compressionHeader;
    connection;
    options;
    compressionReady;
    userData;
    skinData;
    profile;
    version;
    #status;
    constructor(server, connection) {
        super();
        this.server = server;
        this.serializer = server.serializer;
        this.deserializer = server.deserializer;
        this.connection = connection;
        this.options = server.options;
        (0, keyExchange_1.KeyExchange)(this);
        (0, loginVerify_1.default)(this);
        this.#status = exports.ClientStatus.Authenticating;
        if (util_1.isDebug) {
            this.inLog = (...args) => debug('C -> S', ...args);
            this.outLog = (...args) => debug('S -> C', ...args);
        }
        this.batchHeader = this.server.batchHeader;
        this.disableEncryption = this.server.disableEncryption;
        // Compression is server-wide
        this.compressionAlgorithm = this.server.compressionAlgorithm;
        this.compressionLevel = this.server.compressionLevel;
        this.compressionThreshold = this.server.compressionThreshold;
        this.compressionHeader = this.server.compressionHeader;
        this._sentNetworkSettings = false; // 1.19.30+
        this.compressionReady = false;
    }
    getUserData() {
        return this.userData;
    }
    get status() {
        return this.#status;
    }
    set status(val) {
        debug('* new status', val);
        this.emit('status', val);
        this.#status = val;
    }
    sendNetworkSettings() {
        this.write('network_settings', {
            compression_threshold: this.server.compressionThreshold,
            compression_algorithm: this.server.compressionAlgorithm,
            client_throttle: false,
            client_throttle_threshold: 0,
            client_throttle_scalar: 0,
        });
        this._sentNetworkSettings = true;
        this.compressionReady = true;
    }
    handleClientProtocolVersion(clientVersion) {
        // if (this.server.options.protocolVersion) {
        //   if (this.server.options.protocolVersion < clientVersion) {
        //     this.sendDisconnectStatus('failed_spawn') // client too new
        //     return false
        //   }
        // }
        if (clientVersion < Number(options_1.CURRENT_VERSION)) {
            this.sendDisconnectStatus('failed_client'); // client too old
            return false;
        }
        return true;
    }
    onLogin(packet) {
        const body = packet.data;
        this.emit('loggingIn', body);
        const clientVer = body.params.protocol_version;
        if (!this.handleClientProtocolVersion(clientVer)) {
            return;
        }
        // Parse login data
        const tokens = body.params.tokens;
        const authChain = JSON.parse(tokens.identity);
        const skinChain = tokens.client;
        try {
            var { key, userData, skinData } = this.decodeLoginJWT(authChain.chain, skinChain); // eslint-disable-line
        }
        catch (e) {
            debug(this.connection.connectionId, e);
            this.disconnect('Server authentication error');
            return;
        }
        this.emit('server.client_handshake', { key }); // internal so we start encryption
        this.userData = userData.extraData;
        this.skinData = skinData;
        this.profile = {
            name: userData.extraData?.displayName,
            uuid: userData.extraData?.identity,
            xuid: userData.extraData?.xuid || userData.extraData?.XUID,
        };
        this.version = clientVer;
        this.emit('login', { user: userData.extraData }); // emit events for user
    }
    /**
     * Disconnects a client before it has joined
     * @param {string} playStatus
     */
    sendDisconnectStatus(playStatus) {
        if (this.status === exports.ClientStatus.Disconnected)
            return;
        this.write('play_status', { status: playStatus });
        this.close('kick');
    }
    /**
     * Disconnects a client
     */
    disconnect(reason = 'Server closed', hide = false) {
        if (this.status === exports.ClientStatus.Disconnected)
            return;
        this.write('disconnect', {
            hide_disconnect_screen: hide,
            message: reason,
            filtered_message: '',
        });
        this.server.conLog('Kicked ', this.connection.connectionId, reason);
        setTimeout(() => this.close('kick'), 100); // Allow time for message to be recieved.
    }
    // After sending Server to Client Handshake, this handles the client's
    // Client to Server handshake response. This indicates successful encryption
    onHandshake() {
        // https://wiki.vg/Bedrock_Protocol#Play_Status
        this.write('play_status', { status: 'login_success' });
        this.status = exports.ClientStatus.Initializing;
        this.emit('join');
    }
    close(reason) {
        if (this.status !== exports.ClientStatus.Disconnected) {
            this.emit('close'); // Emit close once
            if (!reason)
                this.inLog?.('Client closed connection', this.connection.connectionId);
        }
        this.connection?.close();
        this.removeAllListeners();
        this.status = exports.ClientStatus.Disconnected;
    }
    readPacket(packet) {
        try {
            var des = this.server.deserializer.parsePacketBuffer(packet); // eslint-disable-line
        }
        catch (e) {
            this.disconnect('Server error');
            debug('Dropping packet from', this.connection.connectionId, e);
            return;
        }
        this.inLog?.(des.data.name, (0, util_1.serialize)(des.data.params));
        switch (des.data.name) {
            // This is the first packet on 1.19.30 & above
            case 'request_network_settings':
                if (this.handleClientProtocolVersion(des.data.params.client_protocol)) {
                    this.sendNetworkSettings();
                    this.compressionLevel = this.server.compressionLevel;
                }
                return;
            // Below 1.19.30, this is the first packet.
            case 'login':
                this.onLogin(des);
                if (!this._sentNetworkSettings)
                    this.sendNetworkSettings();
                return;
            case 'client_to_server_handshake':
                // Emit the 'join' event
                this.onHandshake();
                break;
            case 'set_local_player_as_initialized':
                this.status = exports.ClientStatus.Initialized;
                this.inLog?.('Server client spawned');
                // Emit the 'spawn' event
                this.emit('spawn');
                break;
            default:
                if (this.status === exports.ClientStatus.Disconnected || this.status === exports.ClientStatus.Authenticating) {
                    this.inLog?.('ignoring', des.data.name);
                    return;
                }
        }
        this.emit(des.data.name, des.data.params);
        this.emit('packet', des);
    }
    updateItemPalette(palette) {
        // In the future, we can send down the whole item palette if we need
        // but since it's only one item, we can just make a single variable.
        let shieldItemID;
        for (const state of palette) {
            if (state.name === 'minecraft:shield') {
                shieldItemID = state.runtime_id;
                break;
            }
        }
        if (shieldItemID) {
            this.serializer.proto.setVariable('ShieldItemID', shieldItemID);
            this.deserializer.proto.setVariable('ShieldItemID', shieldItemID);
        }
    }
    write(name, params) {
        this.outLog?.(name, params);
        if (name === 'item_registry')
            this.updateItemPalette(params.itemstates);
        const batch = new framer_1.Framer(this);
        const packet = this.serializer.createPacketBuffer({ name, params });
        batch.addEncodedPacket(packet);
        this.sendPacket(batch.encode());
    }
    sendPacket(buffer) {
        if (this.connection.reliable?.readyState !== 'open' || this.status === exports.ClientStatus.Disconnected)
            return;
        try {
            this.connection.write(buffer);
        }
        catch (e) {
            debug('while sending to', this.connection, e);
        }
    }
    onDecryptedPacket = (buffer) => {
        const packets = framer_1.Framer.decode(this, buffer);
        for (const packet of packets) {
            this.readPacket(packet);
        }
    };
}
exports.Player = Player;
